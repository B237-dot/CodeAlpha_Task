# -*- coding: utf-8 -*-
"""car prize prediction using machine learning(task3).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/193F39mCEDUnqrrX3YubjnDof24NCCf7f
"""

import kagglehub

# Download latest version
path = kagglehub.dataset_download("vijayaadithyanvg/car-price-predictionused-cars")

print("Path to dataset files:", path)

#  TASK 3: Car Price Prediction with Machine Learning
# ● Collect car-related features like brand goodwill, horsepower, mileage, etc.
# ● Train a regression model to predict car prices based on these features.
# ● Handle data preprocessing, feature engineering, and model evaluation
# ● Use Python libraries like Pandas, Scikit-learn and Matplotlib for the workflow.
# ● Understand real-world applications of machine learning in price prediction.

import pandas as pd
import os
import numpy as np  # Import numpy for square root
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error, r2_score
import kagglehub # Import kagglehub if not already imported

# Assuming the dataset is downloaded to the specified path
# and contains a CSV file, let's find the CSV file

# The 'path' variable is set in the first cell, let's use that.
# If running this cell independently, you might need to redownload.
try:
    if 'path' not in globals() or path is None:
         path = kagglehub.dataset_download("vijayaadithyanvg/car-price-predictionused-cars")
         print("Path to dataset files:", path)
except Exception as e:
    print(f"Error ensuring dataset download: {e}")
    path = None

data = None
if path is not None:
    # List files in the downloaded directory to find the correct CSV file name
    downloaded_files = os.listdir(path)
    csv_files_in_path = [f for f in downloaded_files if f.endswith('.csv')]

    if len(csv_files_in_path) == 0:
        print(f"No CSV file found in the downloaded dataset path: {path}")
    else:
        # Assuming the first CSV file is the one we need
        csv_file_name = csv_files_in_path[0]
        dataset_file_path = os.path.join(path, csv_file_name)

        try:
            data = pd.read_csv(dataset_file_path)
            print(f"Dataset loaded successfully from: {dataset_file_path}")
        except FileNotFoundError:
            print(f"Error: CSV file not found at {dataset_file_path}. Please check the downloaded dataset content.")

if data is not None:
    # Display the first few rows and information about the dataset
    print(data.head())
    data.info()

    # Check for missing values
    print(data.isnull().sum())

    # Basic statistical summary
    print(data.describe())

    # --- Data Preprocessing and Feature Engineering ---

    # Let's simplify the dataset for this example, focusing on numerical features and a few categorical ones
    # Select relevant features (adjust based on your dataset columns)
    # Replace with actual column names from your dataset based on data.columns
    relevant_features = ['Selling_Price', 'Present_Price', 'Driven_kms', 'Fuel_Type', 'Selling_type', 'Transmission', 'Owner', 'Year', 'Car_Name'] # Include 'Car_Name' initially to check its presence
    # Check if these columns exist in the dataframe
    for col in relevant_features:
        if col not in data.columns:
            print(f"Warning: Column '{col}' not found in the dataset.")
            # You might want to remove missing columns from relevant_features here

    # Filter relevant_features to only include columns present in the dataframe
    actual_relevant_features = [col for col in relevant_features if col in data.columns]

    # Separate target variable before handling categorical features
    target = 'Selling_Price'
    if target not in actual_relevant_features:
         print(f"Error: Target column '{target}' not found in the dataset.")
         data = None # Set data to None to skip further processing if target is missing

if data is not None:
    # Exclude 'Car_Name' from the features used for the model as it's likely not suitable for linear regression
    features_to_use = [col for col in actual_relevant_features if col != target and col != 'Car_Name']

    numerical_cols = data[features_to_use].select_dtypes(include=['number']).columns.tolist()
    categorical_cols = data[features_to_use].select_dtypes(include=['object']).columns.tolist()

    print("\nFeatures selected for the model:", features_to_use)
    print("\nCategorical features identified:", categorical_cols)


    # Drop rows with missing values for simplicity in this example
    # Dropping based on selected features and target
    columns_to_check_for_na = features_to_use + [target]
    data_cleaned = data.dropna(subset=columns_to_check_for_na).copy() # Use .copy() to avoid SettingWithCopyWarning

    # Handle categorical features (one-hot encoding)
    data_cleaned = pd.get_dummies(data_cleaned, columns=categorical_cols, drop_first=True)

    # Update features_to_use after one-hot encoding
    features_to_use_cleaned = [col for col in data_cleaned.columns if col != target and col != 'Car_Name'] # Exclude 'Car_Name' here as well

    print("\nData after one-hot encoding and dropping missing values:")
    print(data_cleaned.head())

    # Define features (X) and target (y)
    # Select only the columns that are in features_to_use_cleaned for X
    X = data_cleaned[features_to_use_cleaned]
    y = data_cleaned[target]

    # --- Model Training ---

    # Split data into training and testing sets
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

    # Initialize and train a Linear Regression model
    model = LinearRegression()
    model.fit(X_train, y_train)

    # --- Model Evaluation ---

    # Make predictions on the test set
    y_pred = model.predict(X_test)

    # Evaluate the model
    mse = mean_squared_error(y_test, y_pred)
    rmse = np.sqrt(mse) # Calculate RMSE as the square root of MSE
    r2 = r2_score(y_test, y_pred)

    print(f'\nMean Squared Error: {mse}')
    print(f'Root Mean Squared Error: {rmse}')
    print(f'R-squared: {r2}')

    # --- Visualization (Optional but Recommended) ---

    # Visualize predictions vs actual prices
    plt.figure(figsize=(10, 6))
    plt.scatter(y_test, y_pred, alpha=0.5)
    plt.xlabel("Actual Price")
    plt.ylabel("Predicted Price")
    plt.title("Actual vs. Predicted Car Prices")
    plt.plot([y_test.min(), y_test.max()], [y_test.min(), y_test.max()], 'k--', lw=2) # Diagonal line for perfect predictions
    plt.show()

    # Visualize distribution of prices
    plt.figure(figsize=(10, 6))
    sns.histplot(data_cleaned[target], kde=True)
    plt.title(f"Distribution of {target}")
    plt.xlabel("Price")
    plt.ylabel("Frequency")
    plt.show()

    # Visualize relationship between a key feature (e.g., Present_Price) and Selling_Price
    # Ensure 'Present_Price' is in the cleaned data before attempting to plot
    if 'Present_Price' in data_cleaned.columns and target in data_cleaned.columns:
        plt.figure(figsize=(10, 6))
        sns.scatterplot(x='Present_Price', y=target, data=data_cleaned, alpha=0.6)
        plt.title(f"Present Price vs. {target}")
        plt.xlabel("Present Price")
        plt.ylabel(target)
        plt.show()
else:
    print("Data was not loaded successfully. Skipping model training and evaluation.")